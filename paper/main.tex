\documentclass[thesismargins, english, thesislinespacing, onelinechapterstyle, upjsfrontpage]{rnthesis}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}

\usepackage{rnt-pic}
\usepackage{rnt-thm}

\usepackage{pdfpages} % inserting pdf pages

\usepackage[hyphens]{url} % format and linebreak of URLs

\usepackage{amssymb}
\newcommand\doublecheck{\checkmark\kern-0.6em\checkmark}

\usepackage{tikz}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{xparse}
% Rotation: \rot[<angle>][<width>]{<stuff>}
\NewDocumentCommand{\rot}{O{60} O{1em} m}{\makebox[#2][l]{\rotatebox{#1}{#3}}}%

\hyphenation{elektro-nic-kých}
\hyphenation{na-ria-dením}
\hyphenation{možno-sťami}
\hyphenation{používateľ-sky}
\hyphenation{akých-koľ-vek}
\hyphenation{zariadenia-mi}
\hyphenation{ope-račné}

\title{Replacing handwritten signatures with open electronic signature software}
\author{Jakub Ďuraš}
\typprace{bachelor's}
\rok{2020}
\odbor{Applied Informatics}
\miesto{Košice}
\veduci{RNDr. Viliam Kačala}
\pracovisko{Institute of Computer Science}
\podakovanie{
I want to thank my supervisor RNDr. Viliam Kačala for his continuous feedback and patience with my questions and late submissions.
I would also like to acknowledge help received from RNDr. JUDr. Pavol Sokol, PhD. and prof. RNDr. Gabriel Semanišin, PhD.
Finally, I would like to thank my family and friends who contributed in various ways to my thesis.
}

\pdfzadanie{assignment.pdf}

\abstract{
With the recent changes in the legal status of electronic signatures in the world, there is an opportunity to expand the use of electronic signatures as an alternative to handwritten signatures outside the usual areas.
In this work, we devote our attention to the exploration of the legal preconditions relevant for the EU, technological preconditions, review of the existing software, and a proposal of our own software platform.
The result is an open software platform for operating systems Windows, macOS, and Linux.
Using this application, it is possible, following the eIDAS Regulation, to sign and verify the signature of any document with the legal effect of an attested signature.
Our solution supports ID cards of the Slovak Republic with the eID chip without any modifications or settings, which enables use outside the web applications of the state.
The application is not tied only to the Slovak eID but is ready for further use with various devices in other countries and as a platform for other types of signatures.
There is also a website that, in addition to the possibility of downloading software and brief documentation, provides general information about electronic signatures.
The emphasis is on the simple extensibility of the program via language translations, documentation, functionality, and general information.
The thesis can be further extended with novel ways of signing or by improving flexibility, which is not completely up to par with the compared software.
}

\keywords{electronic signature, electronic seal, qualified, open-source, XAdES, PAdES, CAdES, desktop software}

\abstrakt{
So zmenami v právnom statuse elektronických podpisov vo svete sa vytvára príležitosť rozšíriť elektronické podpisovanie ako plnohodnotnú náhradu pre vlastnoručné podpisy.
V práci sa venujeme právnym predpokladom relevantným pre EÚ, technologickým predpokladom, prehľadu v súčasnosti dostupného softvéru a návrhu vlastnej softvérovej platformy.
Výsledkom je otvorená softvérová platforma pre operačné systémy Windows, macOS a Linux.
Pomocou aplikácie je možné, v súlade s nariadením eIDAS, podpísať a overiť podpis ľubovoľného dokumentu, ktorý má rovnaký právny účinok ako osvedčený podpis.
Naše riešenie podporuje občianske preukazy Slovenskej Republiky s čipom eID bez akýchkoľvek úprav alebo nastavení, čím sa umožňuje ich využitie mimo použitia vo webových aplikáciách štátu.
Aplikácia nie je viazaná iba na slovenské eID, ale je pripravená na ďalšie použitie s rôznymi zariadeniami v rôznych štátoch a ako platforma pre iné druhy podpisov.
Súčasťou je aj webová stránka, ktorá okrem možnosti stiahnutia softvéru a stručnej dokumentácie poskytuje všeobecné informácie o elektronických podpisoch.
Dôraz je kladený na jednoduchú rozšíriteľnosť programu vo forme jazykových prekladov, dokumentácie, funkcionality a všeobecných informácií.
Prácu je možné ďalej rožšíriť nepreskúmanými možnosťami podpisovania či zlepšením flexibility, ktorá nie je na úrovni niektorých zástupcov porovnávaného softvéru. 
}

\klucoveslova{elektronický podpis, elektronická pečať, kvalifikovaný, open-source, XAdES, PAdES, CAdES, počítačový softvér}

\bibliographystyle{alpha}

\begin{document}
\maketitle

\newpage

\tableofcontents

\uvod

Electronic signatures have been around for a while.
Their practical usability, however, is influenced by their legal status and available infrastructure.
With the recent changes to the relevant laws around the world, and in the European Union specifically, they are seeing increased adoption.

While, specifically in the European Union, electronic signatures seem to be used relatively extensively in communication with the government, they do not seem to have been widely adopted in exchanges between individuals or smaller organizations, which still seem to prefer handwritten signatures.
In many cases, however, they may be impractical for electronic communication, due to the need of a person's physical presence or the printing and sending of documents.

Our goal is to explore an accessible way of using electronic signatures.
In the beginning, we go over the preconditions that make it a viable alternative to handwritten signatures.
We cover the legal preconditions relevant to the European Union, and Slovakia in particular.
Also, we explain the technical preconditions, focusing on cryptographic concepts like asymmetric cryptography, timestamping, hashing, and standards that comply with the laws of the European Union.
Secondly, we do a review of the existing software, where we briefly cover several applications that are meant for basic use.
We compare them using several criteria to find out the strengths and weaknesses of the current implementations and identify a potential gap.
Finally, we devote our attention to our own software's implementation.
We explain the proposed desktop software and go into details on software engineering aspects.
Specifically, we cover usability, localization, modularity, architecture, testing, and automation.
In the end, we compare it to the existing software and identify possible future improvements.
Another result we focus on is a supporting website and how it helps with the use of the software, all in a way that is open for extension by the community.

\chapter{Preconditions and theory}

There are several preconditions that allow us to consider electronic signatures as an alternative.
Firstly, the current state of the law and recent changes relating to the use of electronic signatures. Secondly, well-established concepts in cryptography like asymmetric cryptography or hashing. Lastly, expertise from the field of software engineering - design, implementation, and maintenance of computer software.
We will concentrate on the first two in relation to the electronic signatures and where applicable open-source desktop computer software.

\section{Law}

Unless stated otherwise, we are considering law applicable locally in the Slovak Republic (SR).
Its law is greatly influenced by the European Union (EU), being its member since 2004, and by the rest of the world.
We can assume this is at least partially applicable outside of the SR as well.
Our overall view on the global legal status is shaped by \cite{law}.
Subsection \ref{copyright} is largely based on Chapters 1, 2, 3, 6, and 7 of \cite{osslicensing}.

\subsection{Signatures}

Signatures are an essential part of the written legally binding documents like contracts.
They are permanently affixed to the document and are supposed to uniquely identify the person and its deliberate, informed consent.
As can be seen in the Slovak Civil Code, § 40, a written legal act is valid if signed by the acting person \cite{civilcode}.
Our law often explicitly requires signatures and further clarifies their expected use.
For example, when selling an enterprise, looking at the Commercial Code, § 476, the contract requires written form and attested signatures of the seller and the buyer \cite{commercialcode}.

Signature is considered an \pojem{attested signature}\footnote{Translation from "osvedčený podpis" as used in the Slovak law.} if it is verified by an authorized third party.
This process is referred to as \pojem{legalization} in Notary Law, § 56, and its purpose is to attest information that could form the basis for the exercise of rights or which could cause legal consequences \cite{notarylaw}.

Regarding the electronic signatures, law within the EU used to differ, with the law applicable in the SR being now-repealed \textit{Act No. 215/2002 Coll.}. This situation changed with the EU Regulation eIDAS.

\subsection{EU Regulation eIDAS} \label{eidas}

With intention to stimulate digital growth by building trust, the EU established regulation on electronic identification and trust services for electronic transactions in the internal market (eIDAS).
It applies from 1st of July 2016, replaces local law, and regulates, among other things, electronic signatures and its more specific variants.

\obrazok{./figures/electronic-advanced-qualified}{Relation between electronic, advanced, and qualified signatures.}{signature-comparison}

In general, electronic signature can be represented in different ways (e.g. as an image, text or other data attached to the document) and they can not be denied in legal proceedings just because they are in the electronic form \cite{eidas}.

\pojem{Advanced electronic signatures} are a subset of electronic signatures that have to uniquely link and identify the signature author, be created in a way that is possible only by them and any changes to the signed document have to be detectable \cite{eidas}.
From the technical point of view, standards \pojem{PAdES}, \pojem{XAdES}, and \pojem{CAdES} specified by the European Telecommunications Standards Institute (ETSI) comply with these requirements. We explain why this is the case in Section \ref{cryptography}.

\pojem{Qualified electronic signatures} (QES) are a subset of advanced electronic signatures with more specific requirements that can be found in annex 1 of the eIDAS regulation\footnote{Available at \url{https://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32014R0910\#d1e32-111-1}.}.
In more practical terms, such advanced electronic signatures are created with a qualified device using a qualified certificate and a qualified trust service.
Qualified, in this case, means authorized for such use by the legal authorities.
These devices, certificates, and trust services are explicitly listed by the EU. In many cases indirectly by listing the organization (and its items) from a specific country.

Furthermore, a qualified electronic signature has the legal effect of a handwritten signature \cite{eidas} and attested handwritten signatures in the SR.

Mentioned terminology is used when considering a natural person. Legal entities are able to use \pojem{electronic seals}, which are, from the technical point of view and for our purposes, identical to electronic signatures.

Overall, electronic signatures are supposed to be, within the EU, interoperable and transparent alternative to handwritten signatures.

\subsection{Software copyright} \label{copyright}

Computer programs and associated materials are historically protected under copyright as literary works, and protected authors should be able to authorize or prohibit certain acts \cite{eeccopyright}.

Such right can be exercised to license the software under either proprietary or open-source license.
Proprietary meaning under the exclusive legal right of the author, typically also confidential and distributed as a paid product.
Open-source meaning having its source code freely available, typically also distributed for free and without any liability (the software is provided "as is").

Motivation to license the software under an open-source license can differ, and so do such licenses.
While a proprietary license is usually made specifically for that entity and its interests, open-source licenses tend to be reused between different authors.
This means that consumers of the software can quickly recognize their rights and responsibilities if they decide to use, modify, or distribute the software.
In general, we can classify the open-source licenses into two categories: \pojem{permissive} and \pojem{copyleft}.

Copyleft license, in general, requires the user to publish the modified work under the compatible (free) license.
As a result, it forces them to extend the rights they have received onto others and, in turn, somehow hinder usability in software licensed under a different license.
A popular example of such license is the GNU General Public License (GPL) and its derivatives like GNU Lesser GPL (LGPL) or GNU Affero GPL (AGPL).

Permissive licenses, on the other hand, do not have such a requirement in place and are more suitable for potential commercialization.
They typically allow commercial use, modifications, distribution or sublicensing as long as the author is not held liable, and the original copyright and license are distributed with the software.
Often used permissive licenses are MIT License, Apache License, or BSD License.

It is not uncommon to see hybrid licensing - which means licensing under more than one license, with one being typically open-source and one proprietary.
In this scenario, users can choose which license they want to use based on their needs.

\obrazok{./figures/license-comparison}{Classification and comparison of software licensing models.}{license-comparison}

As we have already mentioned, software licenses can influence whether and how it can be used as a part of different software.
Both when we are the ones using someone else's software and when someone else is using our software.
Generally speaking, the more open the license is, the more likely it is it will not hinder adoption for legal reasons.
We provide examples of categorized licenses in Figure \ref{fig:license-comparison}.

\iffalse % I have no space for this :(
Various possible combinations can be seen in Figure \ref{fig:license-compatibility}, where greyed out options mean such combination is not possible unless a separate licensing agreement is reached with the copyright owner.

\obrazok{./figures/license-compatibility}{Schematic representation of license directionality. \osoba{Morin 2012} \cite{licensing}}{license-compatibility}
\fi

\section{Cryptography} \label{cryptography}

Previously mentioned standards PAdES, XAdES, and CAdES define how asymmetric cryptography, hashing, or timestamping should be used to comply with the standards.
We go over these topics and why they are able to satisfy the requirements for QES mentioned in the Section \ref{eidas}.
We draw our knowledge in chapters about cryptographic primitives from the \cite{cryptotxtbook} and \cite{cryptojoy}.

\subsection{Asymmetric cryptography}

There are several attributes that make symmetric encryption unsuitable.
Let us imagine we are creating a key for each pair of users in our network - imaginary country Isle of Alices and Bobs - for symmetric encryption and decryption of documents shared between each Alice and Bob.

Secure distribution of keys seems to be feasible when we are adding a new user to our network.
We require each user to personally come and pick up a physical device that contains pre-generated keys.
Changes made after that, however, would mean we either need to require a periodic personal visit to update the saved keys or transmission of these keys over some medium, which can be potentially unsafe.
Any new members of the network are unable to participate until other Alices and Bobs get their updates.

Even if we think we have established a reasonably secure way to do that and we are willing to wait, we realize the number of keys is quickly increasing with each new member. With \textit{n} users, the number of keys is

$$\frac{n \cdot (n - 1)}{2}$$

which means that even our little imaginary country with a population of only 70 000 requires roughly 2.5 billion keys. However, since our signature system needs to be portable, we will need to count also with a population of other countries, and so the number of keys grows very quickly.

Either party can also lie about not signing the document.
Since both have the key that can be used for encryption, they can sign any document on behalf of the other party, and there is no way to disprove it if we look at it as a third party.

These issues can be addressed with asymmetric cryptography.
In general, we assign a pair of keys to each person, one of them used for encryption, known as a \pojem{public key}, another used for decryption, known as a \pojem{private key}.
One party can encrypt, and the other is the only one that can decrypt.

\pojem{Digital signatures} are specific asymmetric cryptography algorithms.
The signer is the only one who possesses the private key used for signing, and others can use the public key for signature verification.
We sign the document, including the other parties' signature.

Practical and widely used implementation of this idea is the \pojem{RSA} signature scheme that relies on the integer factorization problem published in 1978 \cite{rsa}.

In Slovakia, the private key is usually handed over to the user personally, saved on the ID card. This ID card, together with a card reader, provides an \pojem{Application Programming Inteface} (API) for safe access, management, and cryptoprocessing.
Such a device is in general called a \pojem{Hardware Security Module} (HSM), and the API relevant for this thesis is \pojem{PKCS \#11} \footnote{PKCS \#11 specification available at \url{http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html}.}.

We are left with the problem of public key distribution - even though public-key schemes do not require a \textit{secure channel}, they require \textit{authenticated channels} for the distribution of the public keys \cite{cryptotxtbook}.

A common solution is the use of \pojem{certificates}.
Certificates are essentially digital signatures with metadata that can be used to establish the validity of the received public key before it is used.
Distribution of such certificates is the responsibility of a \pojem{Certification Authority} (CA) - a third party that all users in the network trust.
In the case of the Slovak ID cards, it is Disig - SVK eID Accredited CA, issued by the National Security Authority\footnote{Translation from "Národný bezpečnostný úrad".}.
Such certificates, therefore, reliably uniquely link and identify the public key owners, as can be seen in Figure \ref{fig:certificate-scheme}\footnote{Created by an unknown author, licensed under the CC BY-SA 3.0 license.}.
Ability to do that is the first requirement for the advanced electronic signatures mentioned in Section \ref{eidas}.
Commonly used standard for public key certificates is X.509\footnote{Specification available under RFC5280 at \url{https://tools.ietf.org/html/rfc5280}.}.

\obrazok{./figures/certificate-scheme}{Application of digital signature with certificate.}{certificate-scheme}

Specific for the EU is online \pojem{List of The Lists} (LOTL) that contains a list with trusted service providers for each country.
Each member state is obligated to maintain such list, as can be seen in Article 22 of \cite{eidas}.
From the technical point of view, it is an XML document that is signed and can be processed automatically.

\subsection{Hashing and timestamping}

It is often useful to map data of arbitrary size to a fixed-length and typically short set of bits called \pojem{hash}.
Function that can be used for it is called \pojem{hash function}.

In cryptography, we are considering only hash functions that can also satisfy these additional requirements:

\begin{enumerate}
  \item \textbf{Deterministic} - same input data are always mapped to the same hash.
  \item \textbf{One-way} - it should be infeasible to retrieve input data for a given hash.
  \item \textbf{Resistant to collisions} - it should be infeasible to find two inputs with the same hash.
  \item \textbf{Avalanche effect} - even small change to the input should lead to significantly different hash.
\end{enumerate}

In the context of digital documents, we can use such hash function to generate a hash for the document.
This hash can represent a document of any size and is used during the creation of a digital signature instead of the document itself.
Any further changes to the document will, therefore, lead to a significantly different hash, which means the digital signature will no longer be valid, and these changes are detected.
This ability is one of the requirements for the advanced electronic signatures from Section \ref{eidas}.
For this purpose, only hash functions that are reasonably fast can be used, so that we can utilize them on documents of variable size.

An example of commonly used hash function family is \pojem{Secure Hash Algorithms} (SHA), with hash functions relevant to this thesis being mainly SHA-2\footnote{SHA-2 specification available in FIPS PUB 180-4 at \url{https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf}.}.

A common part of the paper signed documents is the date when they were signed.
Their digital counterpart is PKI-based \pojem{trusted timestamping} - a process of digitally signing date and time of document creation or modification.
No one should be able to tamper with such timestamp - not even the author of the document.
Additionally, we should not be able to choose arbitrary date and time ourselves, but it should represent the actual time at the signing.

To achieve this, a trusted third party - \pojem{Timestamping Authority} (TSA) - is the one that will sign the hash of the document together with the current date and time.
This process can be seen in Figure \ref{fig:trusted-timestamping}\footnote{Schema created by Bart Van den Bosch, licensed under the CC BY-SA 2.0 BE license.}.
Verifying can be done by decrypting this information using the public key and comparing the hashes.
Any attempt at tampering is therefore detected, which helps to cover requirements for the advanced electronic signatures from Section \ref{eidas}.

\obrazok{./figures/trusted-timestamping}{Setting a timestamp via a trusted third party.}{trusted-timestamping}

The commonly used standard for the \pojem{Public Key Infrastructure} (PKI) based timestamping is part of the X.509\footnote{Specification available under RFC3161 at \url{https://www.ietf.org/rfc/rfc3161.txt}.}.

\subsection{PAdES, XAdES, and CAdES} \label{etsi}

Extensions for Portable Document Format (PDF) files, eXtensible Markup Language (XML) files, and Cryptographic Message Syntax (CMS) signed data for signing using advanced electronic signatures, as explained in Section \ref{eidas}, are PAdES, XAdES, and CAdES, respectively.
They are defined in the respective specifications by the ETSI in \cite{pades}, \cite{xades}, and \cite{cades}.

When using PAdES, signatures are always part of the PDF file itself.
This differs from XAdES, where the signature can be either part of the XML or provided as a separate file, or CAdES where the signature is always in the form of binary data, and it is up to the software.

All of them support multiple signatures applied in succession.
Implementation of the PAdES is rather portable since any compatible PDF file reader or editor will work with the signatures in a similar way - signature created in one should be easily verifiable in any other. XAdES and CAdES, however, are usually tied to specific implementation or standard that is built on top of them.

\begin{table}[!ht]
  \begin{tabular}{ |p{2cm}||p{2.2cm}|p{2cm}|p{3cm}|p{3.9cm}| }
    \hline
    Standard & Usable with & Format & Multi-signature & Appearance \\
    \hline
    PAdES & PDF                  & embedded         & yes, sequential    & supported            \\
    XAdES & XML, any             & XML              & yes                & depends on the usage \\
    CAdES & any                  & binary           & yes                & depends on the usage \\
    \hline
  \end{tabular}

  \caption{Overview of standards PAdES, XAdES, and CAdES.}
  \label{table:1}
\end{table}

The ability to keep signed documents valid for a prolonged period of time is covered in these standards under optional \pojem{Long-Term Validation} (LTV) that allows archiving of documents for many years, possibly decades.
If enabled, a trustworthy timestamp is required as validity is verified for the time the signature (and therefore timestamp) was created.
The expiration time is then limited by the validity of the timestamp certificate.
Different profiles - levels - for different standards can be seen in Table \ref{table:2}.

\begin{table}[!ht]
  \centering
  \begin{tabular}{|l||l|l|l|}
    \hline
    Level                     & XAdES     & CAdES     & PAdES     \\
    \hline
    Basic                     & XAdES-B   & CAdES-B   & AdES-B    \\
    B with Timestamp          & XAdES-T   & CAdES-T   & PAdES-T   \\
    T with Long Term Data     & XAdES-LT  & CAdES-LT  & PAdES-LT  \\
    LT with Archive timestamp & XAdES-LTA & CAdES-LTA & PAdES-LTA \\
    \hline
  \end{tabular}

  \caption{Different profiles - levels - for standards PAdES, XAdES, and CAdES.}
  \label{table:2}
\end{table}

\iffalse % I have no space for this :(
\section{Software engineering}

We will consider Ian Sommerville's definition of software engineeing - "an engineering discipline that is concerned with all aspects of software production from initial conception to operation and maintenance" \cite{sommerville}.
Aspects we will focus on are design, implementation, testing and releasing, and maintenance.
We try to consider specifics of the open-source software as they are sometimes defined in Chapter 7 of \cite{oss}.

\subsection{Design}

TODO: System modeling

TODO: Architectural design

TODO: Design patterns

TODO: Dependability and Security

\subsection{Implementation}

TODO: Requirements engineering

TODO: Software reuse

TODO: Agile software development

\subsection{Testing and Releasing}

TODO: Quality management

TODO: Automated tests (pyramid, V-model)

TODO: Building, Release management

\subsection{Maintenance}

TODO: Evolution processes

TODO: OSS Sustainability
\fi

\chapter{Review of existing software} \label{review}

We focus only on simple applications made mostly for the signing of the documents.
During our review, we have used several PDF files that we have tried to sign using QES available on the SR eID.
We have tried to include software of all types in our review, preferring the most popular, locally available ones, since those should be prepared for the use with the SR eID.
Excluded are all complex applications with advanced features and high price tag.
We have picked one open-source desktop application, one web application - \pojem{Software as a Service} (SaaS), one PDF viewer, one simple paid desktop application, and one commercial desktop application with free version. Criteria we focus on are:

\begin{enumerate}
  \item \textbf{Licensing} - is it freely available - both in terms of money and source code - best case is open-source; worst case is paid proprietary software.
  \item \textbf{Cross-platform compatibility} - is it available for users of all major desktop platforms - best case is availability on Windows, macOS, and Linux; worst case is availability only on one platform.
  \item \textbf{Localization} - is it translated and does it display data like dates in local format - best case is availability at least in English and Slovak language; worst case is availability only in one language with no support for localization of dates, etc..
  \item \textbf{File support} - does it support different file formats and sizes - best case is support for all file formats with sensible size up to 50 MB; worst case is availability only for one file format or strict limits on the file size.
  \item \textbf{Easy setup} - does it require non-trivial setup to use the SR eID - best case is no setup required; worst case is possibly demanding setup or troubleshooting.
  \item \textbf{Flexibility} - how much logic can be customized - best case is various options for signature format, signature policy, used algorithms or timestamping configuration; worst case is none or almost none customization.
  \item \textbf{Built-in verification} - is the verification of signatures available in the same software - best case is ability to verify various signature types; worst case is no support for signature verification.
  \item \textbf{Extensibility} - is it extensible by the community - best case is it is prepared for easy extensibility in terms of functionality and localization; worst case is no extensibility.
\end{enumerate}

We have summarized our findings in Table \ref{table:software}. Value \doublecheck means best-case scenario, no value worst-case scenario, and value \checkmark somewhere in between - partially or depends.

\begin{table}[h!]
  \begin{tabular}{ p{2.75cm}|p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm} }
                      & \rot{licensing} & \rot{cross-platform} & \rot{localization} & \rot{file suppport} & \rot{easy setup} & \rot{flexibility} & \rot{built-in verification} & \rot{extensibility} \\
    \hline
    JSignPdf          & \doublecheck    & \checkmark           &                    &                     &                  & \doublecheck      &                             & \checkmark \\
    zep.disig.sk      & \checkmark      & \doublecheck         & \doublecheck       & \checkmark          & \doublecheck     &                   & \doublecheck                &            \\
    Acrobat DC        & \checkmark      & \checkmark           & \doublecheck       &                     & \checkmark       & \doublecheck      & \doublecheck                &            \\
    D.PDF Signer      &                 &                      & \checkmark         &                     & \doublecheck     & \checkmark        &                             &            \\
    Podpisuj.sk       & \checkmark      & \doublecheck         & \checkmark         & \doublecheck        & \doublecheck     & \checkmark        & \doublecheck                &            \\
  \end{tabular}

  \caption{Comparison of existing software.}
  \label{table:software}
\end{table}

\section{Desktop application JSignPdf}

JSignPdf is an open-source Java application that adds digital signatures to PDF documents. It can be used as a standalone application or as an add-on in OpenOffice. We focus only on standalone use.

\obrazok{./figures/screenshot-jsignpdf}{Screenshot of the JSignPdf version 1.6.4.}{screenshot-jsignpdf}

The application consists only of one window, which makes it very simple at first sight.
The very first input - \textit{Keystore type} - can be harder to understand for the basic user since it contains over a dozen options in the form of abbreviations like \textit{CASEEXACTJKS} or \textit{PKCS12-DEF-3DES-40RC2}.
The default value is \textit{WINDOWS-MY}, however, which is what is exactly required for the SR eID.
Application has a toggle for the \textit{Advanced view}, which is off by default, but it is necessary to turn it on if we want to choose the correct key.
On some of the computers, we were not able to see the key from the eID. On others, it took a while and several pressing of a button to load them.
The correct key was not the first, preselected key in the form of \textit{Name Surname}, but the second \textit{Name Surname (1)}.
With everything set up correctly, the application was successfully able to attach a QES.
Even though the application looks pretty simple, it is still pretty flexible with its options regarding the used algorithms, TSA, OCSP, or CRL.
That being said, it is available only in English, and we have also noticed issues with the diacritics as you can see in Figure \ref{fig:screenshot-jsignpdf} - "Jakub Ďuraš" is displayed as "Jakub Ïura".

\section{Web application zep.disig.sk}

Web application zep.disig.sk is a pro-bono SaaS from company Disig a.s. for user-friendly document signing and validation utilizing the currently bundled software with the SR eID.

\obrazok{./figures/screenshot-zepdisigsk}{Screenshot of the zep.disig.sk.}{screenshot-zepdisigsk}

The process to sign or validate is very simple and straightforward.
There are, however, several potential problems.
Since this is a web service, documents have to be uploaded.
Any confidential or personal data are, therefore, shared with the company.
Additionally, we have no way of knowing "how things work" in the background.
File support is pretty extensive, but there is a strict restriction on file size at 4 MB - larger files such as documents scanned at home will possibly not be accepted.
The website also provides valuable information, and the company seems to be open to questions from users - all completely for free.

\section{PDF viewer Adobe Acrobat Reader DC}

One of the most popular PDF viewers from the company Adobe - Acrobat Reader DC - can also verify and add signatures to PDF files.

\obrazok{./figures/screenshot-adobeacrobat}{Screenshot of the Adobe Acrobat Reader DC.}{screenshot-adobeacrobat}

Using the QES is slightly harder to find in the Adobe Acrobat Reader.
It is not available under \textit{Signing}, but \textit{More Tools} where it is called \textit{Certificates}.
Setup of the certificate for use with the SR eID can be a hit or miss.
On one of our computers, the application would not include a certificate from the SR eID, and we had to go through a process of adding the PKCS \#11 library manually.
That meant we had to go through several steps and windows and disable the \textit{protected mode} option.
The setup of this application may not be straightforward and may require professional help.
On another computer, we were simply able to choose from the list of the available certificates.
That being said, everything is correctly localized, and being one of the most used applications of its kind, it is very easy to search for help in situations like this.
Outside of that, verification of signatures is part of the application and is very responsive and flexible.
The application is proprietary and can not be extended or verified.
It is available only on the Windows and macOS.

\section{Commercial application D.PDF Signer}

Application D.PDF Signer is a paid proprietary desktop application.

\obrazok{./figures/screenshot-dpdfsigner}{Screenshot of the D.PDF Signer.}{screenshot-dpdfsigner}

Just like the zep.digis.sk, D.PDF signer utilizes the currently bundled software with the SR eID.
It is straightforward and flexible.
On the other hand, it lacks support for platforms other than Windows.
Additionally, the application is only partially localized to English.
It does not support file formats other than PDF and has no built-in signature verification.

\section{Commercial desktop application Podpisuj.sk}

Application Podpisuj.sk is a paid proprietary desktop application with a free version developed locally in Slovakia.

\obrazok{./figures/screenshot-podpisujsk}{Screenshot of the Podpisuj.sk.}{screenshot-podpisujsk}

The Podpisuj.sk can be downloaded for all three major desktop platforms.
It does not rely on the software bundled with the SR eID.
It is relatively easy to use and comes fully preconfigured so it can be used with the SR eID right away.
Flexibility is not as great as with some other applications we have reviewed, and some options (like custom TSP) require one of the paid versions.
Not everything is fully localized - especially the website, and any documentation we could find was available only in Slovak.
Therefore it may be impractical for foreigners.
It is not possible to extend it, but it is easy to use different tokens for signing.

\chapter{Results}

\section{Desktop software}

We have developed an open-source, cross-platform desktop software with focus on the modularity, architecture, usability, localization, automated testing with overall automation, and extensibility by the community.
Our knowledge on these topics comes from Ian Sommerville's \cite{sommerville}.
We try to consider specifics of the open-source software as they are sometimes defined in Chapter 7 of \cite{oss}.

\subsection{Usability}

Our main objective for the usability was to provide the end-users with an easy to use, straightforward UI, and to make as many decisions for them as possible.
We have tried to achieve this by using as little controls as possible and by trying to have only one main control that we expect the user to interact with.

\obrazok{./figures/screenshot-octosign}{Screenshot from the main screen of our application Octosign.}{screenshot-octosign}

We hide all unnecessary information and choose a most likely default without asking users to choose from options that could confuse them, or would require them to study to make informed decisions.
We assume this will mean the users will be more confident as there will be fewer steps where they were not sure if they have made the right choice.

Since we are developing this application as a cross-platform desktop application available under a permissive open-source license, it should be usable by as many people as possible.

\subsection{Localization}

We have also made the application easily translatable and try to display data like dates in the local format.
When the application is started, we try to detect the locale of the user and set it as a default language.
If we do not yet support the locale of the user, we default to the English language.
At the time of writing, our application is fully translated in three languages: English (source language), Slovak, and Czech.
Additional languages - German and Spanish - are actively being developed.

The process of content translation is mostly automated.
We start with the automated extraction of the source strings from the code of the main module and files provided by the backends.
Next, we manually include the extracted source strings in the commit to our versioning control - we have retained manual control over this to prevent a noise that automated commits could make.
On push to the hosted repository, a localization platform Transifex\footnote{Transifex is a SaaS localization platform free for OSS, see \url{https://www.transifex.com/}.} automatically pulls and process the updates.
These phrases can then be translated by anybody using the \textit{User Interface} (UI) of the Transifex platform to make it easily accessible.
Once the changes are made on the Transifex platform, it automatically creates a pull request on our hosted repository with the changes made to that particular language.
As we explain in detail in Section \ref{testing}, part of the build process is to incorporate these in the application.

\subsection{Modularity}

Although we focus on the use with the SR eID, we want the application to be extensible by the community and ready for experimentation with new ways of signing.
That is why we have designed our application to be a fully modular platform.

The main module is an Electron\footnote{Electron is a framework allowing the development of desktop software using web technologies.} application written in TypeScript\footnote{TypeScript is statically typed superset of JavaScript that compiles to JavaScript.}.
This module features simple UI and abstraction around modules for signing that we call \pojem{backends}.
It handles all of the communication with the user for the backend and tries to simplify development of the backends as much as possible.

Signing modules - backends - are separate command line interface (CLI) applications written in any programming language.
They are responsible for the actual document manipulation - signing and verification.

The main module loads all available backends at runtime.
Once the user decides to verify or sign a file, they are executed as CLI applications.

Communication between the main module and backends is in plaintext over the standard streams (STDIO) - standard input (STDIN), output (STDOUT), and error (STDERR).
To make sure we have correctly documented and easily accessible way for backend development, we have prepared a Backend specification that specifies what is required of the backend, what is optionally supported, and the format of the inputs, outputs, and error handling.

\obrazok{./figures/modularity}{Modules of our application and their communication.}{modularity}

There are several advantages to this approach.
Firstly, we can write backends in any language that suits us the most.
For example, our backend that allows signing documents with the signatures compliant with the EU eIDAS directive is written in Java because it is based on a library from EU - DSS - also written in Java.
We expect most of the languages have APIs for the consumption of the standard streams with excellent portability across different desktop platforms.
Secondly, since we are technically working on separate applications, they can be written by different people under a different license.
That also means we can easily swap the main module or any of the backends for use in different environments or different bundles.
Thirdly, together with the choice of using standard streams, it means that anyone can quickly start the development of a new backend.
Writing to the standard output stream in CLI application is one of the first things developers usually learn - so-called "Hello World" applications.
It usually should not involve studying any required third-party libraries, and authors can choose the language they are most familiar with.

\subsection{Signing backends} \label{backends}

Following our specification, each backend is required to provide a configuration file and follow the communication protocol.

Configuration files are written in YAML\footnote{YAML is a human-readable data serialization language, see \url{https://yaml.org/}.} and contain basic information about the backend like name, description, repository, version, author, or license.
It also contains two properties defining what command should be executed and with what parameters to execute the backend, and build the backend, respectively.

Backend is always called with operation as the first argument, followed by an additional argument that differs between operations.
The backend should be stateless - that means it should not be influenced by any state it would save like info about what files it signed.
All communication is in UTF-8 encoded plaintext.
It needs to implement operations \texttt{meta}, \texttt{sign}, and \texttt{verify} that are run using the configured executable, for example, \texttt{./backend-executable meta}, or, \texttt{./backend-executable sign /home/path.pdf}.

Operation meta is called to get info about its availability, options, and supported file types.
This allows the backend to check the platform, available software of the user, etc. and make the decision based on that.

Operation sign and verify are called to sign or verify the file with the absolute path to the file.
The main module never sends anything over the STDIO unless it's asked to do so from the backend.
That means the backend acts as a \texttt{master} and the main module as a \texttt{slave}.
The UI can end the process if any unexpected situation arises and displays an error.
The backend can during those two operations, at any moment: write error to the STDERR that is immediately displayed; prompt for additional information by writing to the STDOUT; get the current value of any option by writing to the STDOUT.

Ending the process with the exit code 0 signals success.
Some operations expect a result on the STDOUT before the process exits.
If code other than 0 is used, the backend should always send an error message to the STDERR.

Messages exchanged via the STDIN and STDOUT can be sometimes polluted by different libraries used on either part, so they are distinguished from the rest by using the following delimiter:

\begin{verbatim}
---TYPE---
any information exchanged in the appropriate format
---TYPE---
\end{verbatim}

\texttt{TYPE} here is replaced by \texttt{PROMPT}, \texttt{GETOPTION}, or \texttt{RESULT} based on the type of the message.
Such messages should be written in one chunk and flushed. Communication on the STDERR is accepted and displayed as-is.

Prompt is used to interactively ask for more information from the user.
The backend can ask to get an absolute path to the output file, absolute path to opened file, text, password, image (drawn or picked), or position and width of the signature that will be placed in the UI by the user.

Getting an option is used to ask for the current option value that can be set in the UI on the Settings screen.
The option is automatically prefixed on the main module for each backend so it can not retrieve options from other backends to prevent collisions and security issues.

Such communication protocol allows using any language that can simply work with the STDIO without a need for knowledge or third-party libraries to work with serialized data in formats like JSON.
The backend does not have to use any regular expressions but always simply reads the whole line.
It is supposed to be as simple as possible for newcomers.

The current version of the full specification is available at \url{https://github.com/durasj/octosign/wiki/Backend-specification}.

\subsubsection{DSS eIDAS backend}

The backend that we call \pojem{advanced electronic signature}, is a Java CLI application that uses \pojem{Digital Signature Service} (DSS) framework. 
The DSS is a project from the Connecting Europe Facility (CEF) Digital, a European Union fund for pan-European infrastructure investment.
It is one of the \textit{}{Building Blocks}, as they are called on their website, which helps to create and verify electronic signatures in line with European standards.
Its documentation, available in \cite{ecdss}, also provides general information about the used standards.

Source of the private key is configurable, and we can use PKCS \#11 to utilize those in HSMs, PKCS \#12 to work with key stores in files, or Microsoft Crypto API that provides an abstraction on different sources.
It supports all standards mentioned in Chapter \ref{etsi} in various configurations.
Since we are trying to simplify it down for the user, when signing, we automatically choose to use PAdES when signing PDF, XAdES when signing XML with enveloped signature, and ASiC with CAdES for all other file formats.
This could be further extended in the future, so the user can manually choose the preferred standard, container type, or signature policy.

Signature verification, however, works with all different combinations that are detected automatically.
During the verification, we construct a trusted list of root certificates from the LOTL.
Different lists for different countries are hosted individually on each countries servers.
For better performance and reliability when there is an outage on those servers, we proxy requests through CloudFlare\footnote{CloudFlare is a CDN provider, see \url{https://www.cloudflare.com/}.} \pojem{Content Delivery Network} (CDN) to distribute cached files that are periodically downloaded and stored on the Amazon Web Services\footnote{Amazon Web Services is a cloud provider with various services, see \url{https://aws.amazon.com/what-is-aws/}.} (AWS) infrastructure using the AWS Lambda and AWS S3.

We also support adding a visible signature for PDFs.
This helps users to recognize it was digitally signed without a need to mention it in the document itself and provides information on who or when signed it.
Labels are translated using the current language of the application as we assume this will be the language the receiver will most likely speak.

The backend currently supports configurable TSP URL, so any TSP following the RFC 3161 can be utilized as long as it does not require authentication.
Authentication is usually done using a name and password or using a digital signature but is currently not supported.
This could hinder use with qualified TSPs that usually require authentication.

One issue we were facing when working with the DSS framework is the assumption that it is often implemented on the server-side as a service.
This meant that some APIs are meant to be used in an environment where they are started once, and then they are available or can be run periodically several times a day.
This is obviously not the case with our architecture since we always run it only when some operation is required, and the application is stopped again.
We assume this issue can come up during the development of other backends as well and may require a certain level of flexibility from the developer to tackle them.

\subsubsection{Image backend}

To provide users with the ability to sign using a simple image saved on the computer, which is probably a scanned signature, or signature drawn directly in our application, we created what we call \textit{simple image signature} backend.
It is useful when users do not have the resources required to sign the document using the QES, or in situations when they would rather not do so.

It is written in Go and utilizes a library for manipulation of PDF files.
Its purpose is just to ask the main module for the signature file and its position.
Therefore, this backend utilizes prompt functionality of the communication protocol with options image and position.

Option to draw the signature in the application is using a splining algorithm with a variable stroke that calculates the time it takes to travel between two points.
Such signatures mimic one of the features of the handwritten signatures from \cite{verification} that are used to verify the authenticity of handwritten signatures.
That being said, we are not aware of any proof that this approach has any practical benefits outside of aesthetics.
This approach was outlined on the Square Engineering Blog\footnote{Smoother Signatures article available archived at \url{https://web.archive.org/web/20150211220342/http://corner.squareup.com/2012/07/smoother-signatures.html}.}.
There is a JavaScript implementation for the browser called Signature Pad\footnote{Signature Pad library is available at \url{https://github.com/szimek/signature_pad}.}.

\subsection{Architecture of the main module} \label{architecture}

Our main module is the most complex one.
Electron applications have a main thread that is running a Node.js\footnote{Node.js is a JavaScript runtime for use outside of the browser with easier access to the OS APIs.} and a UI thread running the relevant part of the Chromium\footnote{Chromium is a popular open-source browser project, see \url{https://www.chromium.org/Home}.}.
Their communication is done via \pojem{inter-process communication} (IPC) and allows access to the Node.js APIs in the UI thread.
Considering the JavaScript is interpreted at runtime, we are exposing ourselves to potential attacks (mostly XSS\footnote{XSS means Cross-site scripting, see \url{https://owasp.org/www-community/attacks/xss/}.}).
To reduce the attack surface, as Node.js allows easy access to many APIs like full access to the filesystem, we have fully separated the UI thread and main thread.
Our work was influenced by knowledge from \cite{eloquentjs} and \cite{ydkjs}.

The main thread is focused only on the communication with the backends and provides the only absolutely necessary functionality for the UI.
They are connected by a very thin level of abstraction - a set of functions that are bound on the \textit{window} object during the initialization by the main thread and, when called from the UI thread, automatically communicate via IPC.
All of the UI code and main thread code is, therefore, also fully portable and could also be used in a different setup - for example, in a web application or mobile application.
We would be mostly required to only change the thin level of abstraction - implement the interface we have created on the \textit{window} object.
Furthermore, it allows us to develop the UI in the browser with a mocked main thread and also allows for easy UI testing, which we go over in Section \ref{testing}.

\subsection{Testing and automation} \label{testing}

When approaching automated testing, we have decided to implement the testing pyramid as defined by Mike Cohn in \cite{succeedingagile}.
One of the implementations of this idea was done by the Ham Vocke in \cite{practicalpyramid}.
It is implemented at a scale at Google, which explains their positive experience with it in \cite{nomoree2e}.
Following this approach, we write three types of tests: end-to-end, integration, and unit tests.
The ratio of these types of tests should form a pyramid where the heavy bottom is formed by the unit tests, followed by a smaller set of component tests forming the middle of the pyramid, and a small set of end-to-end tests forming the tip of the pyramid.
The motivation behind this approach is to write more tests that are faster and break less often due to better isolation, as opposed to tests that are slower and break more often.

In our case, we have decided to write unit tests in Jest testing both the UI and main thread code, component tests in Jest for the main thread and Cypress for the UI thread combined with the Percy, and end-to-end tests as Spectron tests which run and interact with the actual distributables (executable files).
We are able to fully isolate each type of tests because of our architecture that allows easy mocking.
We explain the architecture in Section \ref{architecture}.

Our code is kept in a git repository\footnote{Repository is available at \url{https://github.com/durasj/octosign}.} hosted at Github and is a source for the Continuous Integration (CI) and Continuous Delivery (CD) pipeline.
For the CI/CD, we are using Azure Pipelines specifically, that are free for OSS.
On each push, apart from setting up the environment, we perform static analysis on the code checking the type safety using TypeScript, code style using the ESLint and Prettier, code quality using the CodeClimate.com, and check for potential vulnerabilities using the Snyk.io.
As for the mentioned automated tests, we run the unit and components tests and monitor the coverage using the Codecov.io.
In the case coverage would be significantly negatively impacted, the Pull Request (PR) is blocked from being merged.
Backends are referenced in the same repository by using the git submodules, which allows us to simplify the development and build process.
Build process build individual backends, the main thread, UI thread, and API code, and uploads bundled distributable files for all platforms back to the Github.
The whole process runs for each platform - Windows, Linux, and macOS - separately; therefore, there is no need for cross-compiling and running of platform-dependent tools in virtualized environments.
Publishing of the new release is then done by saving the release in the Github.

We had to overcome issues we have faced with the performance of the Github relases - mainly apparent bandwidth restrictions.
We have deployed an AWS lambda that is called when a new release is published on Github and sends a message to AWS Simple Queue Service (SQS).
Another AWS Lambda is triggered on such message, and it downloads all distributable files and creates a metafile with information about the release in AWS S3.
These files are then served cached over the CDN from CloudFlare.

\subsection{Comparison with existing software}

\begin{table}[h!]
  \begin{tabular}{ p{2.75cm}|p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm}p{0.85cm} }
                      & \rot{licensing} & \rot{cross-platform} & \rot{localization} & \rot{file suppport} & \rot{easy setup} & \rot{flexibility} & \rot{built-in verification} & \rot{extensibility} \\
    \hline
    JSignPdf          & \doublecheck    & \checkmark           &                    &                     &                  & \doublecheck      &                             & \checkmark   \\
    zep.disig.sk      & \checkmark      & \doublecheck         & \doublecheck       & \checkmark          & \doublecheck     &                   & \doublecheck                &              \\
    Acrobat DC        & \checkmark      & \checkmark           & \doublecheck       &                     & \checkmark       & \doublecheck      & \doublecheck                &              \\
    D.PDF Signer      &                 &                      & \checkmark         &                     & \doublecheck     & \checkmark        &                             &              \\
    Podpisuj.sk       & \checkmark      & \doublecheck         & \checkmark         & \doublecheck        & \doublecheck     & \checkmark        & \doublecheck                &              \\
    \hline
    Our - Octosign    & \doublecheck    & \doublecheck         & \doublecheck       & \doublecheck        & \checkmark       & \checkmark        & \doublecheck                & \doublecheck \\
  \end{tabular}

  \caption{Comparison of existing software with our software.}
  \label{table:software-our}
\end{table}

Using our review from Chapter \ref{review}, we have compared our application in Table \ref{table:software}. Value \doublecheck means best-case scenario, no value worst-case scenario, and value \checkmark somewhere in between - partially or depends.

Our software is available under a permissive license (see Section \ref{copyright} for why this matters), supports all major desktop platforms, available in several locales, with support for practically all file types and sizes, with built-in verification and easy extensibility.

In the future, we can improve our application to be easier to set up for more users and be more flexible in the configuration of TSPs or used signature policy.
That being said, we need to consider each configurable functionality we add as it increases complexity which could mean our software is harder to understand.

\section{Website}

Goal of the website is to both support the application in the form of Download page and Help page and provide a to provide a general information on electronic signatures.
The website is, at the time of writing, available in English and Slovak language.

\obrazok{./figures/website-home}{Home page of the octosign.com website.}{website-home}

\subsection{Downloads}

Downloads are available for each major desktop platform in a format suitable for installation or integration in the operating system.
For Windows, we are distributing an \texttt{EXE} installer working on all supported 64-bit Windows versions.
For Linux, a portable \texttt{AppImage} and a \texttt{DEB} package for Debian-like distributions.
For macOS, a \texttt{DMG} disk image.

All of the distributables originate from the Github as assets of a release, where they are uploaded by the CI (see Section \ref{testing}).
Each release is tied to a tag on the master branch, where each commit has to be signed using a recognized PGP key.
In turn, we have some level of confidence source code used for the distributables comes from one of the authors.

To improve on this further, we are doing a \pojem{code-signing} for each release using a trusted way for each platform.
On macOS, this means enrolling in the Apple Developer Program that requires an annual fee and installation of signing certificates.
Additionally, it is necessary to \textit{notarize} the application for use on macOS.
Notarization is an automated process required by Apple to prove that the application does not contain any malicious code and is properly signed and configured.
If the application is not notarized, Gatekeeper will warn the user about the potentially unsafe software.
On modern versions of Windows, applications that are not code-signed can trigger a warning or, depending on the settings, even completely prevent the user from using software that is not code-signed using a certificate that is cosigned with a trusted root certificate.
Certification for individuals on the macOS seems to be fully automated, does not involve lengthy verification, and costs 99 USD a year.
Certification on Windows is offered by various trusted third parties like DigiCert.com that we have used and involves lengthy, partially automated verification at a price starting from 60 USD a year.
At the time of writing, there does not seem to be any service offering code-signing certificates to OSS for free.

\subsection{Information and help}

Our website provides a simple help page with different use cases that should allow users to start using the application quickly.
It also contains a brief explanation of more advanced features of the application like settings.

Another issue we try to solve with the website is a lack of understanding of electronic signatures.
Some users do not know if they are a viable alternative, why is that the case, and how they should be used properly.
We also plan to provide more detailed information for people who are curious about the specifics of the signatures used in the eIDAS scheme.

These pages are written in markdown - a lightweight markup language, making it more accessible for editing by the community that does not need to understand specific technologies used to display content on the website.

\subsection{Technologies}

From the technological point of view, the website is a \pojem{Single Page Application} (SPA) using Gatsby written in React.
Even though it is a SPA, it is \pojem{prerendered} to static HTML and CSS files that are served from CDN, which improves performance and allows for better \pojem{Search Engine Optimization} (SEO).

The website is using CI/CD services from Netlify.com that is also responsible for distribution using a CDN.
Each push on the master branch triggers a build and deploy on the live website.
Each PR has a deploy preview that is basically a unique link that shows proposed changes built and deployed on the web.
Such approach allows for easy iteration and allows others to contribute the content in markdown files without a need to build the website locally as they can see results as soon as they open the PR.

Different language mutations are denoted by using a suffix, for example, the home page is written in English and Slovak using file names \texttt{home.en.tsx} and \texttt{home.sk.tsx}.
Same applies for content written in markdown, for example, help page on basic usage is written in files \texttt{basic.en.md} and \texttt{basic.sk.md}.
The URL of the website contains language code of the current language if it is other than English, for example, the download page is available in English on path \texttt{/download} and in Slovak on path \texttt{/sk/download}.
By switching the language using the selector on the upper right, the URL changes to the required format.

\zaver

We verified that the main legal and technical preconditions should be met for the use of electronic signatures.
We therefore believe they are a viable alternative to handwritten signatures.

We did a review of the existing software, focusing on licensing, cross-platform compatibility, localization, file support, ease of setup, flexibility, verification ability, and extensibility.
We identified the positive and negative sides of the current implementations and found a gap in the software for signing using qualified electronic signatures.

Therefore, we proposed a simple open-source software platform that aims to be straightforward for the end-user by choosing the most likely defaults and reducing the amount of information the user has to interact with.
Also, we made our application easy to translate using a third-party web UI where anyone from the community can contribute translations.
Our application is available in three languages: English, Slovak, and Czech, with German and Spanish in translation.
It is also fully modular, dividing the main module that contains the UI and modules performing the document manipulation.
We implemented a module for signing using qualified electronic signatures that follow European standards and should be compliant with European law, and a module that allows signing using a scanned or drawn signature.
The proposed software is a platform on which others can quickly build new ways of signing documents complying with different laws or basing further research.
From a software engineering perspective, the implementation is robust, and we covered testing and automation in connection with Electron applications like ours.
On the other hand, there is some room for improvement in flexibility and ease of setup of our software.
We also created a supporting website that provides download links for all major desktop platforms, a help page, and general information on electronic signatures.
Our project should be open to people from different countries, speaking different languages, and open for contributions from people with various skills - not just from programmers.

\chapter*{Resumé}
\addcontentsline{toc}{chapter}{Resumé}

Overili sme, že hlavné predpoklady pre použitie elektronických podpisov by mali byť naplnené.
Veríme, že sú preto schodnou alternatívou pre vlastnoručné podpisy.

Preskúmali sme existujúci softvér so zameraním na licenciu, kompatibilitu medzi platformami, lokalizáciu, podporu súborov, ľahkosť nastavenia, flexibilitu, schopnosť overiť podpisy a rozšíriteľnosť.
Identifikovali sme pozitívne a negatívne stránky súčasných implementácií a našli sme medzeru v softvéri na podpisovanie pomocou kvalifikovaných elektronických podpisov.

Preto sme navrhli jednoduchú otvorenú softvérovú platformu, ktorá sa snaží byť priamočiara pre koncového používateľa výberom pravdepodobných predvolených hodnôt a znížením množstva informácií, s ktorými sa používateľ stretáva.
Taktiež sme uľahčili preklad našej aplikácie pomocou webového rozhrania tretej strany, s ktorým môže ktokoľvek z komunity pomôcť prekladmi.
Naša aplikácia je dostupná v troch jazykoch: angličtine, slovenčine a češtine s nemčinou a španielčinou v prekladaní.
Je tiež plne modulárna, kde hlavný modul obsahuje používateľské rozhranie a niekoľko modulov vykonáva manipuláciu s dokumentmi.
Implementovali sme modul na podpisovanie pomocou kvalifikovaného elektronického podpisu, ktorý spĺňa európske štandardy a mal by byť v súlade s európskymi zákonmi a modul, ktorý umožňuje podpisovanie pomocou naskenovaného alebo nakresleného podpisu.
Navrhovaný softvér je platforma, na ktorej môžu ostatní rýchlo vybudovať nové spôsoby podpisovania dokumentov v súlade s rôznymi zákonmi alebo založiť ďalší výskum.
Venovali sme sa testovaniu a automatizácii vývoja Electron aplikácií, takže implementácia je robustná aj z pohľadu softvérového inžinierstva.
Na druhej strane existuje priestor na zlepšenie flexibility a jednoduchosti prvotného nastavenia nášho softvéru.
Vytvorili sme tiež podpornú webovú stránku s možnosťou stiahnutia pre hlavné počítačové operačné systémy, užívateľskou príručkou a všeobecnými informáciami o elektronických podpisoch.
Náš projekt je otvorený ľuďom z rôznych krajín, rozprávajúcich rôznymi jazkymi a zmenám od ľudí s rôznymi zručnosťami - nie len programátorom.

%\renewcommand{\bibname}{Zoznam použitej literatúry}
\begin{thebibliography}{9}
  % Príklady popisu dokumentov citácií podľa systému meno a dátum (Harvardský systém)
  % ----
  % Varianty zápisov autorov:
  % [1] GUZANIN, Štefan, Robert SABOVČÍK a Pavol KAČMÁR. Priezviská vždy VEĽKÝMI PÍSMENAMI,
  %   priezvisko prvého autora je vždy pred menom, druhý a ďalší autor majú zápis
  %   Meno PRIEZVISKO
  % [2] Neuvádzať rodné mená autorov.
  % [3] Verzálky nie sú povinné, možno použiť aj iné indikatívnejšie označenie
  %
  % --- 
  % 1. Knižná publikácia (monografia, učebnica, zborník ...)
  %   1 autor

  %  ------
  % Law
  %  ------
  \bibitem{civilcode}
  \emph{Act No. 40/1964 Coll. Civil Code}

  \bibitem{commercialcode}
  \emph{Act No. 513/1991 Coll. Commercial code}

  \bibitem{notarylaw}
  \emph{Act No. 323/1992 Coll. Notary Law}

  \bibitem{eidas}
  \emph{REGULATION (EU) No 910/2014 OF THE EUROPEAN PARLIAMENT AND OF THE COUNCIL, OJ L 257, 28.8.2014, p. 73–114}

  \bibitem{eeccopyright}
  \emph{Council Directive 91/250/EEC of 14 May 1991 on the legal protection of computer programs, OJ L 122, 17.5.1991, p. 42–46}

  \bibitem{law}
  \osoba{MASON, Stephen}, 2017. \emph{Electronic Signatures in Law: Fourth Edition}. London: University of London. ISBN 978-1-911507-01-7. Available at: \url{https://humanities-digital-library.org/index.php/hdl/catalog/view/electronicsignatures/1/86-1}

  \bibitem{osslicensing}
  \osoba{LAURENT, Andrew}, 2008. \emph{Understanding Open Source and Free Software Licensing}. Sebastopol: O’Reilly Media. ISBN 978-0596005818.

  %  ------
  % Crypto
  %  ------
  \bibitem{cryptotxtbook}
  \osoba{PAAR, Christof} and \osoba{Pelzl, Jan}, 2009. \emph{Understanding Cryptography - A Textbook for Students and Practitioner}. Berlin: Springer. ISBN 978-3-642-04100-6.

  \bibitem{cryptojoy}
  \osoba{ROSULEK, Mike}. \emph{The Joy of Cryptography} [online]. Oregon: School of Electrical Engineering \& Computer Science, Corvallis, Oregon, USA [cit. 2020-04-18]. Available at: \url{http://web.engr.oregonstate.edu/rosulekm/crypto/crypto.pdf}

  \bibitem{rsa}
  \osoba{RIVEST, R. L.}, \osoba{SHAMIR, A.}, and \osoba{ADLEMAN, L.}, 1978. \emph{A method for obtaining digital signatures and public-key cryptosystems}. In: \emph{Communications of the ACM, 21(2):120–126, February 1978.}

  \bibitem{pades}
  ETSI TS 102 778-1 V1.1.1 2007-07. \emph{PAdES Overview - a framework document for PAdES}. Sophia Antipolis: European Telecommunications Standards Institute. Available at: \url{https://www.etsi.org/deliver/etsi_ts/102700_102799/10277801/01.01.01_60/ts_10277801v010101p.pdf}

  \bibitem{xades}
  ETSI TS 101 903 V1.4.2 2010-12. \emph{XML Advanced Electronic Signatures (XAdES)}. Sophia Antipolis: European Telecommunications Standards Institute. Available at: \url{https://www.etsi.org/deliver/etsi_ts/101900_101999/101903/01.04.02_60/ts_101903v010402p.pdf}

  \bibitem{cades}
  ETSI TS 101 733 V2.2.1 2013-04. \emph{CMS Advanced Electronic Signatures (CAdES)}. Sophia Antipolis: European Telecommunications Standards Institute. Available at: \url{https://www.etsi.org/deliver/etsi_ts/101700_101799/101733/02.02.01_60/ts_101733v020201p.pdf}

  %  ------
  % Tech
  %  ------
  \bibitem{sommerville}
  \osoba{SOMMERVILLE, Ian}, 2016. \emph{Software Engineering, 10th Edition}. Harlow: Pearson Education. ISBN 978-0-13-394303-0.

  \bibitem{succeedingagile}
  \osoba{Cohn, Mike}, 2009. \emph{Succeeding with Agile}. Boston: Addison-Wesley Professional. ISBN 978-0-32-166053-4.

  \bibitem{practicalpyramid}
  \osoba{Vocke, Ham}, 2018. \emph{The Practical Test Pyramid} [online]. Available at \url{https://martinfowler.com/articles/practical-test-pyramid.html}

  \bibitem{nomoree2e}
  \osoba{Wacker, Mike}, 2015. \emph{Just Say No to More End-to-End Tests} [online]. Available at \url{https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html}

  \bibitem{oss}
  \osoba{FOGEL, Karl}, 2019. \emph{Producing Open Source Software} [online]. [cit. 2020-04-21]. Available at: \url{https://producingoss.com/en/index.html}

  \bibitem{eloquentjs}
  \osoba{HAVERBEKE, Marijn}, 2018. \emph{Eloquent JavaScript, 3rd Edition}. San Francisco: No Starch Press. ISBN 978-1593279509.

  \bibitem{ydkjs}
  \osoba{SIMPSON, Kyle}, 2020. \emph{You Don't Know JS Yet (book series) - 2nd Edition} [online]. Available at: \url{https://github.com/getify/You-Dont-Know-JS}

  \bibitem{ecdss}
  \osoba{Vandenbroucke, P.} and \osoba{Beliakov, A.} [online]. \emph{Digital Signature Service}. Luxembourg: CEF Digital [cit. 2020-05-16]. Available at: \url{https://ec.europa.eu/cefdigital/DSS/webapp-demo/doc/dss-documentation.html}

  \bibitem{verification}
  \osoba{Hafemann, G. L.}, \osoba{Sabourin, R.}, and \osoba{Oliveira, S. L.}, 2017. Offline Handwritten Signature Verification - Literature Review. In: \emph{2017 Seventh International Conference on Image Processing Theory, Tools and Applications (IPTA)}, pp. 1-8. Montreal: IEEE. ISBN 978-1-5386-1842-4. Available at: \url{https://arxiv.org/abs/1507.07909}

\end{thebibliography}

\prilohy
An up-to-date version of each developed asset is available online on the URL specified in the list.
The version available at the time of writing is part of the attached CD, and the user manual is also available as Appendix A.

List of the most important assets available online and on the CD:

\begin{itemize}
  \item Software Octosign - repository with source code: \url{https://github.com/durasj/octosign}.
  \item Software Octosign - released distributable files: \url{https://github.com/durasj/octosign/releases}.
  \item Signing backend DSS - repository with source code: \url{https://github.com/durasj/octosign-dss}.
  \item Signing backend Image - repository with source code: \url{https://github.com/durasj/octosign-image}.
  \item Website octosign.com - repository with source code: \url{https://github.com/durasj/octosign-website}.
  \item Documentation - short user manual: \url{https://octosign.com/help/basics}.
  \item Documentation - signing backend specification: \url{https://github.com/durasj/octosign/wiki/Backend-specification}.
\end{itemize}

\priloha{User manual}

\section{Downloading and installing the application}

Open the subpage \textit{Download} on website \url{https://octosign.com} where you can download the application by clicking on the button for your operating system.
After the download is complete, open the file and follow the instructions.

\section{Signing the document}

First, it is needed to select a document. To select a document, click on the button \textit{SELECT FILES} or drag and drop your document on the application.
The recommended document type is PDF, although other file types are supported as well.
After selecting the document, a card with the document name will appear just like in the picture.

\scaledobrazok{./figures/screenshot-manual-unsigned}{Screenshot with unsigned document.}{manual-unsigned}{0.5}

Signing is possible using several different types of signatures visible in the upper part of the screen.
The default type is \textit{Advanced electronic signature}, if available, else \textit{Simple image signature}.
When signing with an image, there is only a drawn or picked signature image placed on the PDF.
When signing with an advanced electronic signature, it is possible to use a qualified electronic signature.
To sign a document, press the button \textit{SIGN} visible on the document card.
Follow the instructions, and after the signing is successful, the document will be marked as \textit{Signed}.

\scaledobrazok{./figures/screenshot-manual-signed}{Card with the signed document.}{manual-signed}{0.5}

\section{Verifying of document signature}

Verification of the document signature is automatically started after the document is selected, and it does not have to be triggered manually.

\scaledobrazok{./figures/screenshot-manual-verifying}{Card with the document that is being verified.}{manual-verifying}{0.5}

After the verification is completed, the status of the document will be visible on the card of the document, it can be: \textit{Signed}, \textit{Unsigned}, \textit{Invalid}, \textit{Unknown}, and \textit{Indeterminate}.

If there is at least one signature attached to the document, it is possible to see more information about it by clicking on the button \textit{OPEN SIGNATURE DETAILS}.

\section{Settings}

Settings can be opened by clicking on the text \textit{Settings} in the lower right corner of the application.

It is possible to set the language and options specific for the type of the signature.

\scaledobrazok{./figures/screenshot-manual-settings}{Screenshot with open Settings.}{manual-settings}{0.5}

Options available for the Advanced electronic signature backend are:

\textbf{PKCS \#11 Library Path} - The path is automatically prefilled if there is a supported known software installed on the computer. If not, it is possible to fill it manually with the path that you can get from the supplier of the software bundled with your device. The path needs to lead to a library compliant with the PKCS \#11 standard in a 64-bit version.

\textbf{Timestamping Server URL} - The URL is automatically prefilled with value "http://timestamp.digicert.com". In the case you would like to use your own timestamping server, feel free to change it, but please make sure to type in the full URL address, including the protocol ("http://" or "https://").

\end{document}
